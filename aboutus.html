<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAMEOSKY Terminal</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
      }
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            font-family: "JetBrains Mono", "Fira Code", "Courier New", monospace;
            overflow: hidden;
            position: relative;
            background-color: rgb(0, 0, 0);
        }

        .main-container {
            display: flex;
            width: 100%;
            position: relative;
            z-index: 10;
            min-height: 100vh;
            align-items: center;
            justify-content: center;
        }

        .spiral-nav {
            position: fixed;
            top: 50%;
            left: 90px;
            width: 80px;
            height: 80px;
            transform: translateY(-50%);
            z-index: 1000;
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .spiral {
            width: 100%;
            height: 100%;
            animation: spin 8s linear infinite;
            filter: drop-shadow(0 0 10px #ff4500);
        }

        .spiral-nav:hover .spiral,
        .spiral-about:hover .spiral,
        .spiral.paused {
            animation-play-state: paused;
        }

        .spiral path {
            stroke: #ff4500;
            stroke-width: 2;
            fill: none;
            stroke-linecap: round;
        }

        .nav-links {
            position: fixed;
            top: 50%;
            left: 90px;
            width: 400px;
            height: 400px;
            transform: translate(-50%, -50%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 999;
        }

        .nav-links.show-links {
            opacity: 1;
            pointer-events: auto;
        }

        .nav-link {
            position: absolute;
            transform: translate(-50%, -50%);
            color: #ff4500;
            text-decoration: none;
            font-size: 0.9em;
            padding: 8px 16px;
            border: 2px solid #ff4500;
            border-radius: 25px;
            transition: all 0.3s ease;
            background: rgba(255, 69, 0, 0.1);
            backdrop-filter: blur(10px);
            white-space: nowrap;
            z-index: 100;
        }

        .nav-link:hover {
            background: rgba(255, 69, 0, 0.8);
            color: rgb(255, 255, 255);
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .spiral-about {
            position: absolute;
            top: 75%;
            left: 85%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            transform: translate(-50%, -50%);
            z-index: 101;
        }

        .about-content {
            flex: 1;
            padding: 40px 20px;
            opacity: 1;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .terminal-container {
            width: 100%;
            max-width: 1200px;
            height: 700px;
            margin: 0 auto;
            background: rgba(255, 69, 0, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(255, 69, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            overflow: hidden;
            border: 1px solid rgba(255, 69, 0, 0.2);
            display: flex;
            flex-direction: column;
            transition: transform 0.1s ease-in-out;
        }

        .terminal-container.shake {
            animation: screen-shake 0.3s;
        }

        .terminal-header {
            background: rgba(255, 69, 0, 0.1);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 69, 0, 0.2);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        #header-logo-container {
            width: 20px;
            height: 20px;
        }

        .terminal-title { color: #ff4500; font-size: 0.9em; font-weight: 500; text-align: center;}

        .terminal-body {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            color: rgb(255, 255, 255);
            font-family: "JetBrains Mono", "Fira Code", "Courier New", monospace;
            font-size: 14px;
            line-height: 1.4;
            overflow-y: auto;
            flex-grow: 1;
            position: relative;
        }

        .terminal-body::-webkit-scrollbar { width: 12px; }
        .terminal-body::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.3); border-radius: 6px; }
        .terminal-body::-webkit-scrollbar-thumb { background: #ff4500; border-radius: 6px; border: 2px solid rgba(0, 0, 0, 0.3); }
        .terminal-body::-webkit-scrollbar-thumb:hover { background: #ff6500; }
        .terminal-body { scrollbar-width: thin; scrollbar-color: #ff4500 rgba(0, 0, 0, 0.3); }

        .terminal-content { display: block; height: 100%; }

        .terminal-intro-grid {
            display: flex;
            gap: 20px;
            border-bottom: 1px solid rgba(255, 69, 0, 0.3);
            padding-bottom: 15px;
            margin-bottom: 15px;
        }

        .ascii-art-animation {
            color: #ff4500;
            font-size: 12px;
            line-height: 0.85;
            font-family: monospace;
            white-space: pre;
            user-select: none;
            flex-shrink: 0;
        }

        .intro-details { flex-grow: 1; }
        .retro-title { color: #ff4500; font-family: monospace; white-space: pre; font-size: 16px; margin-bottom: 10px; }
        .intro-text { color: #e0e0e0; font-size: 0.95em; line-height: 1.5; }
        .intro-text strong { color: #ff4500; }

        #command-history { margin-bottom: 10px; }
        .terminal-line { margin: 10px 0; display: flex; flex-wrap: wrap; }
        .prompt { color: #ff4500; margin-right: 8px; font-weight: bold; white-space: nowrap; }
        .command { color: rgb(255, 255, 255); }
        .output { color: #c7c7c7; white-space: pre-wrap; margin-top: 5px; }
        .python-output { color: #e0e0e0; white-space: pre; font-family: monospace; }
        .python-error { color: #ff6347; white-space: pre-wrap; }
        .ai-response { color: #66ff66; white-space: pre-wrap; margin-top: 5px; border-left: 2px solid #66ff66; padding-left: 10px;}

        #command-input-line { display: flex; }
        #command-input { color: #ffffff; background: transparent; border: none; outline: none; flex-grow: 1; caret-color: #ff4500; }
        .typing-cursor { animation: blink 1s infinite; background-color: #ff4500; display: inline-block; width: 8px; height: 1.2em; margin-left: 2px; vertical-align: text-bottom; opacity: 1 !important; }

        .terminal-link { color: #ff4500; text-decoration: none; padding: 2px 6px; border: 1px solid #ff4500; border-radius: 4px; margin: 2px; display: inline-block; transition: all 0.3s ease; background: rgba(255, 69, 0, 0.1); }
        .terminal-link:hover { background: rgba(255, 69, 0, 0.8); color: white; box-shadow: 0 0 10px rgba(255, 69, 0, 0.5); }

        #game-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #ff4500; font-family: 'Courier New', Courier, monospace; display: none; flex-direction: column; align-items: center; justify-content: center; padding: 10px; user-select: none;
        }
        #game-screen { white-space: pre; font-size: 16px; line-height: 1; text-align: center; border: 2px solid #ff4500; padding: 10px; background: rgba(255, 69, 0, 0.05); box-shadow: inset 0 0 15px rgba(255, 69, 0, 0.4); }
        #game-stats { margin-top: 10px; font-size: 16px; width: 100%; max-width: 800px; text-align: center; padding: 0 10px; display: flex; justify-content: space-between; flex-wrap: wrap; }
        #game-controls { margin-top: 10px; font-size: 14px; color: #c7c7c7; width: 100%; max-width: 800px; text-align: center; }
        
        .player { font-weight: bold; color: white; text-shadow: 0 0 5px white;}
        .mothership { font-weight: bold; color: #00ffff; text-shadow: 0 0 8px #00ffff; }
        .enemy { font-weight: bold; color: #ff8c66; text-shadow: 0 0 5px #ff8c66; }
        .enemy-tank { font-weight: bold; color: #ff6347; text-shadow: 0 0 6px #ff6347; }
        .enemy-fast { font-weight: bold; color: #f0e68c; text-shadow: 0 0 5px #f0e68c; }
        .boss { font-weight: bold; color: #ff0000; text-shadow: 0 0 8px #ff0000;}
        .boss-health-bar { color: #ff0000; background-color: #555; }
        .bullet { color: #fff; font-weight: bold; }
        .enemy-bullet { color: #ff6347; font-weight: bold; }
        .boss-bullet { color: #ff00ff; text-shadow: 0 0 5px #ff00ff; }
        .explosion { color: #ff4500; animation: explosion-fade 0.3s forwards; }
        .powerup { font-weight: bold; animation: powerup-glow 1.5s infinite alternate; }
        .powerup-shield { color: #00ffff; text-shadow: 0 0 8px #00ffff; }
        .powerup-rapid { color: #ffff00; text-shadow: 0 0 8px #ffff00; }
        .powerup-health { color: #32cd32; text-shadow: 0 0 8px #32cd32; }
        .powerup-bomb { color: #ff4500; text-shadow: 0 0 8px #ff4500; }
        .powerup-mothership { color: #00ffff; text-shadow: 0 0 8px #00ffff; }

        .chat-message { margin: 5px 0; line-height: 1.3; }
        .chat-message-number { color: #ff4500; font-size: 0.9em; margin-right: 8px; display: inline-block; width: 30px; text-align: right; }
        .chat-message-time { color: #ff8c00; font-size: 0.8em; margin-right: 8px; }
        .chat-message-user { color: #66ff66; font-weight: bold; }
        .chat-message-text { color: #e0e0e0; }
        .chat-reply-context { color: #a0a0a0; font-style: italic; }
        .auth-prompt { color: #66ff66; margin-top: 5px; }
        .auth-success { color: #66ff66; }
        .auth-error { color: #ff6347; }
        .secret-prompt { color: #ff4500; filter: blur(3px); transition: all 0.3s; }
        .secret-prompt:hover { filter: blur(0); }

        /* --- KNOWLEDGE MAP UPDATED STYLES --- */
        #search-view-container {
            display: none;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #knowledge-map-display {
            display: flex;
            flex-direction: row; 
            height: calc(100% - 50px);
            width: 100%;
            gap: 10px;
        }

        /* --- INFO PANEL (LEFT VIEW) --- */
        #map-info-panel {
            flex: 1; /* Takes 1/3 of space */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #info-content-container {
            flex: 2;
            display: flex;
            flex-direction: column;
            border: 1px solid #ff4500;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: hidden;
        }
        #info-content {
             padding: 15px;
             overflow-y: auto;
             flex-grow: 1;
        }
        #info-content::-webkit-scrollbar { width: 8px; }
        #info-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.5); }
        #info-content::-webkit-scrollbar-thumb { background: #ff4500; }
        .info-title {
            color: #ff4500;
            font-weight: bold;
            font-size: 1.2em;
            border-bottom: 1px solid #ff4500;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .info-summary {
            color: #e0e0e0;
            font-size: 0.9em;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .info-summary .topic-link {
            color: #ff8c00;
            text-decoration: underline;
            cursor: pointer;
            font-weight: bold;
        }
        .info-summary .topic-link:hover {
            color: #ffae42;
        }
        
        #ai-analysis-container {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed rgba(255, 69, 0, 0.3);
        }
        #ai-analysis-container .ai-response {
            font-size: 0.9em;
            margin-top: 10px;
        }
        
        /* --- UPGRADED: IMAGE PANEL --- */
        #image-panel {
            flex: 1;
            border: 1px solid #ff4500;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        #image-panel img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 4px;
        }
        #image-panel .placeholder-text {
            color: #888;
            font-style: italic;
        }
        
        /* --- RIGHT COLUMN (MAP AND GRID) --- */
        #map-content-area {
            flex: 2; /* Takes 2/3 of space */
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        /* --- NEURAL MAP (BIG VIEW) --- */
        #neural-map-container {
            flex: 3; 
            min-height: 0;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #ff4500;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        #neural-map-container .label {
            color: #fff;
            font-family: "JetBrains Mono", monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 2px 5px;
            border-radius: 3px;
            text-shadow: 0 0 5px #000;
            pointer-events: auto;
            cursor: pointer;
            transition: color 0.3s, text-shadow 0.3s, opacity 0.3s;
        }
        /* MODIFIED: Changed highlight color to orange */
        #neural-map-container .label.highlight {
            color: #ffae42;
            text-shadow: 0 0 8px #ffae42;
        }
        
        /* --- GRID CONTAINER (SMALL VIEW) --- */
        #map-grid-container {
            flex: 1;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 10px;
            align-content: start;
            padding: 10px;
            border: 1px solid rgba(255, 69, 0, 0.2);
            border-radius: 8px;
        }
        #map-grid-container::-webkit-scrollbar { width: 8px; }
        #map-grid-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.5); }
        #map-grid-container::-webkit-scrollbar-thumb { background: #ff4500; }
        
        /* --- UPGRADED: Suggestion Buttons --- */
        .map-node-retro {
            color: #e0e0e0;
            background-color: rgba(255, 69, 0, 0.1);
            border: 1px solid #ff4500;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95em;
            line-height: 1.4;
            overflow: hidden;
            text-align: center;
            border-radius: 4px;
            text-shadow: 0 0 2px rgba(0,0,0,0.7);
        }
        .map-node-retro:hover {
            background-color: rgba(255, 69, 0, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 69, 0, 0.3);
            color: #ffffff;
        }
        .map-node-retro.active-node {
            background-color: #ff4500;
            border-color: #ffae42;
            color: black;
            font-weight: bold;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .map-node-retro.highlighted-node {
            border-color: #fff;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
            z-index: 10;
            position: relative;
        }
        .node-title { font-weight: bold; }
        
        #search-controls {
            flex-shrink: 0;
            height: 50px;
            padding-top: 5px;
            padding-bottom: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            font-size: 1em;
            color: #c7c7c7;
            border-top: 1px solid rgba(255, 69, 0, 0.2);
        }

        #knowledge-search-input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #ff4500;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: "JetBrains Mono", monospace;
            width: 50%;
            text-align: center;
            flex-grow: 1;
            max-width: 400px;
        }
        #knowledge-search-input::placeholder { color: #888; }
        #knowledge-search-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
            border-color: #ffae42;
        }
        
        /* --- UPGRADED: Navigation Buttons --- */
        .search-nav-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 69, 0, 0.2);
            border: 1px solid #ff4500;
            color: #e0e0e0;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: "JetBrains Mono", monospace;
            font-weight: bold;
            font-size: 1em;
        }
        .search-nav-btn:hover:not(:disabled), .search-nav-btn:focus {
            background: rgba(255, 69, 0, 0.5);
            color: white;
            box-shadow: 0 0 12px rgba(255, 100, 0, 0.6);
            outline: none;
        }
        .search-nav-btn:disabled {
            background: rgba(80, 80, 80, 0.2);
            border-color: rgba(120, 120, 120, 0.5);
            color: #777;
            cursor: not-allowed;
            text-shadow: none;
        }
        
        @keyframes explosion-fade { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(1.5); } }
        @keyframes powerup-glow { from { opacity: 0.7; transform: scale(1); } to { opacity: 1; transform: scale(1.1); } }
        @keyframes screen-shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }

        @media (max-width: 1024px) {
            #knowledge-map-display { flex-direction: column; }
            #map-content-area, #map-info-panel {
                flex: 1; 
            }
            #image-panel {
                min-height: 150px;
            }
        }

        @media (max-width: 768px) {
            .main-container { padding-left: 20px; padding-top: 100px; flex-direction: column; }
            .spiral-nav { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); width: 50px; height: 50px; z-index: 2000; }
            .nav-links { top: 20px; left: 50%; transform: translate(-50%, 0); width: 300px; height: 100px; z-index: 1999; }
            .about-content { padding: 20px 10px; margin-top: 70px; }
            .terminal-container { max-width: 95%; height: 75vh; max-height: 600px; }
            .terminal-intro-grid { flex-direction: column; gap: 10px; }
            .ascii-art-animation { font-size: 8px; align-self: center; }
            .terminal-body { font-size: 12px; }
            .retro-title { font-size: 12px; }
            .intro-text { font-size: 0.85em; }
            .spiral-about { position: absolute; top: 50%; left: 80%; width: 40px; height: 40px; }
            #game-screen { font-size: 12px; }
            #game-stats { font-size: 12px; }
            #map-info-panel { flex: 0.5; max-height: 200px; }
        }

        @media (max-width: 480px) {
            .terminal-container { height: 70vh; max-height: 500px; }
            .spiral-nav { width: 40px; height: 40px; }
            .nav-links { width: 250px; height: 80px; }
            .nav-link { font-size: 0.8em; padding: 6px 12px; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
</head>

<body>
    <div class="main-container">
        <div class="spiral-nav" id="spiralContainer">
             <svg class="spiral" viewBox="-50 -50 100 100">
                <path id="spiral" fill="none" stroke="#ff4500" stroke-width="2"></path>
            </svg>
            <div class="nav-links" id="navLinks">
                <a href="spiral.html" class="nav-link" style="top: 20%; left: 80%;">Home</a>
                <div class="spiral-about" id="aboutSpiral" style="top: 50%; left: 80%;">
                    <svg class="spiral" viewBox="-50 -50 100 100">
                        <path id="aboutSpiralPath" fill="none" stroke="#ff4500" stroke-width="2"></path>
                    </svg>
                </div>
                <a href="#" class="nav-link" style="top: 80%; left: 80%;">Github</a>
            </div>
        </div>

        <div class="about-content show-content" id="aboutContent">
            <div class="terminal-container" id="terminalContainer">
                <div class="terminal-header">
                    <div id="header-logo-container">
                        <svg class="spiral" viewBox="-50 -50 100 100">
                            <path id="headerSpiralPath" fill="none" stroke="#ff4500" stroke-width="4"></path>
                        </svg>
                    </div>
                    <div class="terminal-title" id="terminal-title">CAMEOSKY@arch-terminal</div>
                </div>

                <div class="terminal-body" id="terminalBody">
                    <div id="terminal-content">
                        <div class="terminal-intro-grid">
                            <div id="ascii-animation-container" class="ascii-art-animation"></div>
                            <div class="intro-details">
                                <pre class="retro-title">
      ____                          ____  _
     / ___|__ _ _ __ ___   ___  ___ / ___|| | ___   _
    | |   / _` | '_ ` _ \ / _ \/ _ \\___ \| |/ / | | |
    | |__| (_| | | | | | |  __/ (_) |___) |   <| |_| |
     \____\__,_|_| |_| |_|\___|\___/|____/|_|\_\\__, |
                                               |___/
    <span style="color: #ffffff;">    ~ Welcome to CAMEOSKY terminal ~</span>
                                </pre>
                                <p class="intro-text">
                                Idk i was just bored. Type <strong>help</strong> for a list of commands, Type <strong>play</strong> to start the game. Type <strong>greyskin</strong> to access the secure chat channel (hidden). Type <strong>Search</strong> to search terms in a neural network. Type <strong>Python</strong> to run your personal code. Sandbox no data stored except chat which you can request for removal at <strong>Greycameosky@gmail.com</strong><br>
                                </p>
                            </div>
                        </div>

                        <div id="command-history"></div>
                        <div class="terminal-line" id="command-input-line">
                            <span class="prompt" id="terminal-prompt">[cameosky@arch ~]$</span>
                            <input type="text" id="command-input" autocomplete="off" autofocus>
                            <span class="typing-cursor"></span>
                        </div>
                    </div>

                    <div id="game-container">
                        <div id="game-screen"></div>
                        <div id="game-stats"></div>
                        <div id="game-controls"></div>
                    </div>

                    <div id="search-view-container">
                        <div id="knowledge-map-display">
                            <div id="map-info-panel">
                               <div id="info-content-container">
                                   <div id="info-content">
                                       </div>
                               </div>
                               <div id="image-panel">
                                   <span class="placeholder-text">Search for a term to see an image...</span>
                               </div>
                            </div>
                            <div id="map-content-area">
                                <div id="neural-map-container"></div>
                                <div id="map-grid-container"></div>
                            </div>
                        </div>
                         <div id="search-controls">
                             <button id="search-back-btn" class="search-nav-btn" disabled>&lt; Back</button>
                             <input type="text" id="knowledge-search-input" placeholder="Search another topic or 'quit' to exit...">
                             <button id="search-forward-btn" class="search-nav-btn" disabled>Fwd &gt;</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // --- 3D/Firebase/Pyodide Imports ---
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase project configuration.
       const firebaseConfig = {
          apiKey: "AIzaSyBnqLJxoaIjzpVUA9jXscDYrjED5yLhJmg",
          authDomain: "greyskin-7e568.firebaseapp.com",
          databaseURL: "https://greyskin-7e568-default-rtdb.firebaseio.com",
          projectId: "greyskin-7e568",
          storageBucket: "greyskin-7e568.firebasestorage.app",
          messagingSenderId: "179377879369",
          appId: "1:179377879369:web:071a8725d93163691f0298",
          measurementId: "G-RHKB6D9XQL"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        document.addEventListener('DOMContentLoaded', () => {

            // --- GLOBAL ELEMENTS ---
            const commandInput = document.getElementById('command-input');
            const historyContainer = document.getElementById('command-history');
            const terminalContainer = document.getElementById('terminalContainer');
            const terminalBody = document.getElementById('terminalBody');
            const terminalContent = document.getElementById('terminal-content');
            const gameContainer = document.getElementById('game-container');
            const spiralContainer = document.getElementById('spiralContainer');
            const navLinks = document.getElementById('navLinks');
            const terminalTitle = document.getElementById('terminal-title');
            const terminalPrompt = document.getElementById('terminal-prompt');
            const searchViewContainer = document.getElementById('search-view-container');
            const mapGridContainer = document.getElementById('map-grid-container');
            const mapInfoPanel = document.getElementById('map-info-panel');
            const infoContent = document.getElementById('info-content');
            const imagePanel = document.getElementById('image-panel');
            const searchBackBtn = document.getElementById('search-back-btn');
            const searchForwardBtn = document.getElementById('search-forward-btn');
            const knowledgeSearchInput = document.getElementById('knowledge-search-input');
            const neuralMapContainer = document.getElementById('neural-map-container');


            // --- STATE VARIABLES ---
            let inGame = false;
            let inChat = false;
            let inAIMode = false;
            let inSearchMode = false;
            let currentUser = null;
            let unsubscribeChat = null; 
            let chatMessages = []; 
            let activeIntervals = [];
            let inPythonMode = false;
            let pyodide = null;
            let pyodideReady = false;
            let pythonCodeBlock = '';

            let authState = {
                inProgress: false,
                mode: null, 
                step: 0, 
                email: '',
                password: ''
            };
            
            // --- AUDIO ENGINE ---
            const audio = (() => {
                let audioCtx;
                const init = () => {
                    if (!audioCtx) {
                        try {
                            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        } catch (e) {
                            console.warn('Web Audio API is not supported in this browser');
                        }
                    }
                };

                 const playSound = (type, freq, duration, finalFreq = freq, volume = 0.1) => {
                    if (!audioCtx) return;
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    oscillator.type = type;
                    gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(finalFreq, audioCtx.currentTime + duration);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + duration);
                };

                return {
                    init,
                    delete: () => playSound('triangle', 600, 0.08, 600, 0.2),
                    error: () => playSound('sawtooth', 120, 0.15, 100, 0.2),
                    shoot: () => playSound('triangle', 880, 0.1, 440, 0.15),
                    hit: () => playSound('square', 200, 0.1, 150, 0.2),
                    explosion: () => playSound('sawtooth', 400, 0.4, 50, 0.3),
                    levelUp: () => playSound('sine', 523, 0.5, 1046, 0.25),
                    powerUp: () => playSound('sine', 600, 0.2, 1200, 0.2), 
                    shieldDown: () => playSound('sawtooth', 300, 0.3, 100, 0.25), 
                    bomb: () => playSound('sawtooth', 800, 0.8, 20, 0.4),
                    bossHit: () => playSound('square', 100, 0.15, 80, 0.3),
                    warning: () => playSound('sine', 880, 0.5, 880, 0.2),
                    accessGranted: () => playSound('sine', 880, 0.3, 1760, 0.3),
                    accessDenied: () => playSound('sawtooth', 100, 0.5, 50, 0.3),
                    chatMessage: () => playSound('triangle', 523, 0.1, 659, 0.15)
                };
            })();

            document.body.addEventListener('click', audio.init, { once: true });
            document.body.addEventListener('keydown', audio.init, { once: true });

            // --- SPIRAL NAVIGATION LOGIC ---
            spiralContainer.addEventListener('mouseenter', () => navLinks.classList.add('show-links'));
            spiralContainer.addEventListener('mouseleave', () => navLinks.classList.remove('show-links'));

            function generateSpiralPaths() {
                 const spirals = [
                    document.getElementById('spiral'), 
                    document.getElementById('aboutSpiralPath'),
                    document.getElementById('headerSpiralPath')
                ];
                spirals.forEach(spiralPath => {
                    if (!spiralPath) return;
                    let path = 'M 40 0';
                    const turns = 6; const points = 200;
                    for (let i = 0; i <= points; i++) {
                        const t = (i / points) * turns * Math.PI * 2;
                        const r = 40 * (1 - (i / points) * 0.9);
                        path += ` L ${(r * Math.cos(t)).toFixed(2)} ${(r * Math.sin(t)).toFixed(2)}`;
                    }
                    spiralPath.setAttribute('d', path);
                });
            }

            // --- ASCII BINARY FLOW ANIMATION (Reused for Mascot) ---
            function runAsciiAnimation(container, isMascot = false) {
                const canvas = container;
                if (!canvas) return;
                
                const width = isMascot ? 25 : 45; 
                const height = isMascot ? 14 : 28;
                let grid = []; 
                let time = 0;

                const initGrid = () => { grid = Array(height).fill().map(() => Array(width).fill(' ')); };
                const render = () => { canvas.textContent = grid.map(row => row.join('')).join('\n'); };
                
                function update() {
                    initGrid();
                    const t = time * 0.02;
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const dx = x - width / 2;
                            const dy = y - height / 2;
                            const flow = Math.sin(x * 0.2 + y * 0.1 + t) + Math.sin(Math.sqrt(dx * dx + dy * dy) * 0.4 - t * 2);
                            if (flow > 0.8) grid[y][x] = '█';
                            else if (flow > 0.4) grid[y][x] = '░';
                            else if (flow > 0.0) grid[y][x] = '·';
                            else if (flow < -0.8) grid[y][x] = '@';
                            else if (flow < -0.4) grid[y][x] = '*';
                            else if (flow < -0.0) grid[y][x] = '~';
                        }
                    }
                    time++;
                }

                function animate() {
                    if (!document.body.contains(canvas)) {
                        const intervalId = activeIntervals.find(i => i.canvas === canvas);
                        if (intervalId) {
                            clearInterval(intervalId.id);
                            activeIntervals = activeIntervals.filter(i => i.canvas !== canvas);
                        }
                        return;
                    }
                    if(inGame && !isMascot) { requestAnimationFrame(animate); return; }; 
                    update(); 
                    render(); 
                    requestAnimationFrame(animate);
                }
                animate();
            }
            
            // --- PYTHON INTEGRATION (PYODIDE) - NON-BLOCKING ---
            function initializePyodide() {
                printOutput("Initializing Python runtime in the background...", null);
                setTimeout(async () => {
                    try {
                        pyodide = await loadPyodide();
                        pyodideReady = true;
                        printOutput("Python runtime ready. Type 'python' to enter the REPL.", true);
                    } catch (error) {
                        pyodideReady = false;
                        printOutput("Error loading Python runtime. Python features will be unavailable.", false);
                        console.error("Pyodide loading error:", error);
                    }
                }, 100);
            }

            async function runPythonCode(code) {
                if (!pyodideReady) {
                    printOutput("Python runtime is not available.", false);
                    return;
                }
                let stdout_data = "";
                let stderr_data = "";
                const loadingMsg = document.createElement('div');
                try {
                    loadingMsg.className = 'output';
                    loadingMsg.textContent = 'Analyzing imports and loading required packages...';
                    historyContainer.appendChild(loadingMsg);
                    terminalBody.scrollTop = terminalBody.scrollHeight;
                    pyodide.setStdout({ batched: (data) => { stdout_data += data + "\n"; } });
                    pyodide.setStderr({ batched: (data) => { stderr_data += data + "\n"; } });
                    await pyodide.loadPackagesFromImports(code);
                    loadingMsg.textContent = 'Packages loaded. Executing code...';
                    let result = await pyodide.runPythonAsync(code);
                    loadingMsg.remove();
                    if (stdout_data) printOutput(stdout_data.trimEnd(), null, 'python-output');
                    if (stderr_data) printOutput(stderr_data.trimEnd(), false, 'python-error');
                    if (result !== undefined) printOutput(String(result), null, 'python-output');
                } catch (err) {
                    if(loadingMsg) loadingMsg.remove();
                    printOutput(String(err), false, 'python-error');
                } finally {
                    pyodide.setStdout({});
                    pyodide.setStderr({});
                }
            }
            
            // --- VOID-STRIKER GAME ENGINE (UNCHANGED) ---
            const Game = {
                display: null, statsDisplay: null, controlsDisplay: null, width: 70, height: 30, player: {}, bullets: [], enemies: [], explosions: [], powerUps: [], keys: {}, level: 1, score: 0, highScore: 0, enemySpawnCounter: 0, gameLoopInterval: null, isGameOver: false, boss: null, bossActive: false, screenShakeTimer: 0, levelIntroTimer: 0,
                story: [
                    { level: 1, text: "Sector 1: An unknown energy signature has been detected. Begin reconnaissance." },
                    { level: 2, text: "Hostile ships detected! They're primitive, but numerous. Clear them out." },
                    { level: 3, text: "!! WARNING: Large hostile approaching! This is a Sector Guardian. Destroy it!" },
                    { level: 4, text: "Sector 2: You're in their main territory now. Expect heavy resistance." },
                    { level: 5, text: "They're adapting... faster and more aggressive ships have been deployed." },
                    { level: 6, text: "!! BOSS BATTLE: The 'Enforcer' drone is here. Its armor is thick, find a weak point!" },
                    { level: 7, text: "Sector 3: The signal is getting stronger. You're entering the heart of the Void's influence." },
                    { level: 8, text: "They're throwing everything they have at you. This is a suicide run. Hold the line!" },
                    { level: 9, text: "!! FINAL BOSS: You've reached the source. The Cosmic Void itself. End this, pilot!" },
                ],
                bossTypes: [
                    { name: 'Guardian', hp: 120, art: [ " >-A-< ", "<[O_O]>", " v-V-v " ], attackPatterns: [
                        { type: 'spread', count: 3, damage: 10, cooldown: 90 },
                        { type: 'spawn', enemyType: 'basic', count: 2, cooldown: 150 },
                        { type: 'bombingRun', count: 4, damage: 15, cooldown: 180}
                    ]},
                    { name: 'Enforcer', hp: 250, art: [ "/|#|#|\\", "[|O-O|]", "\\|#|#|/" ], attackPatterns: [
                        { type: 'barrage', damage: 15, cooldown: 80 },
                        { type: 'spawn', enemyType: 'fast', count: 1, cooldown: 160 },
                        { type: 'bombingRun', count: 6, damage: 20, cooldown: 140}
                    ]},
                     { name: 'Cosmic Void', hp: 500, art_frames: [[ "  ~ · ~  ", "· ~ █ ~ ·", "  ~ · ~  " ], [ "   * * ", "* ░ █ ░ *", "   * * " ], [ "  * · * ", "· ▒ █ ▒ ·", "  * · * " ], [ "   ~ ~   ", "~ ▓ █ ▓ ~", "   ~ ~   " ]], art: [], artFrame: 0, artUpdateCounter: 0, attackPatterns: [
                        { type: 'spread', count: 5, damage: 20, cooldown: 60 },
                        { type: 'spawn', enemyType: 'tank', count: 1, cooldown: 100 },
                        { type: 'spawn', enemyType: 'fast', count: 2, cooldown: 100 },
                        { type: 'bombingRun', count: 12, damage: 25, cooldown: 90 }
                    ]}
                ],
                init: function() {
                    this.display = document.getElementById('game-screen');
                    this.statsDisplay = document.getElementById('game-stats');
                    this.controlsDisplay = document.getElementById('game-controls');
                    gameContainer.style.display = 'flex'; terminalContent.style.display = 'none';
                    inGame = true; this.isGameOver = false; this.bossActive = false; this.boss = null;
                    this.player = { x: this.width / 2, y: this.height - 3, char: '▲', hp: 100, shield: 50, rapidFire: 0, shootCooldown: 0, baseShootCooldown: 8, bombs: 2, mothershipTimer: 0, mothership: null };
                    this.bullets = []; this.enemies = []; this.explosions = []; this.powerUps = [];
                    this.level = 1; this.score = 0; this.enemySpawnCounter = 0;
                    this.highScore = localStorage.getItem('voidStrikerHighScore') || 0;
                    this.controlsDisplay.innerHTML = `Controls: [WASD]/[Arrows] Move | [Space] Shoot | [B] Bomb | [Q] Quit <br> High Score: ${this.highScore}`;
                    this.showLevelIntro();
                    this.gameLoopInterval = setInterval(() => this.gameLoop(), 50);
                },
                showLevelIntro: function() {
                    const intro = this.story.find(s => s.level === this.level);
                    if (intro) {
                        this.levelIntroTimer = 80; 
                        this.display.innerHTML = `\n\n\n\n\n\n\n<div style="color: #ff4500; font-size: 1.2em;">LEVEL ${this.level}</div>\n<div>${intro.text}</div>`;
                    }
                },
                gameLoop: function() { 
                    if (this.levelIntroTimer > 0) {
                        this.levelIntroTimer--;
                        return;
                    }
                    if (this.screenShakeTimer > 0) { this.screenShakeTimer--; if(this.screenShakeTimer === 0) terminalContainer.classList.remove('shake'); }
                    if (!this.isGameOver) { this.update(); this.draw(); } 
                },
                shakeScreen: function(duration) { this.screenShakeTimer = duration; terminalContainer.classList.add('shake'); },
                update: function() {
                    if ((this.level % 3 === 0) && !this.bossActive && this.enemies.length === 0) {
                        this.spawnBoss();
                    }
                    if (this.bossActive) this.updateBoss();
                    if (this.keys['a'] || this.keys['ArrowLeft']) this.player.x = Math.max(1, this.player.x - 1);
                    if (this.keys['d'] || this.keys['ArrowRight']) this.player.x = Math.min(this.width - 2, this.player.x + 1);
                    if (this.keys['w'] || this.keys['ArrowUp']) this.player.y = Math.max(1, this.player.y - 1);
                    if (this.keys['s'] || this.keys['ArrowDown']) this.player.y = Math.min(this.height - 2, this.player.y + 1);
                    if (this.player.shootCooldown > 0) this.player.shootCooldown--;
                    if (this.player.rapidFire > 0) this.player.rapidFire--;
                    if (this.player.mothershipTimer > 0) {
                        this.player.mothershipTimer--;
                        if (this.player.mothershipTimer === 0) { this.player.mothership = null; }
                        else { this.updateMothership(); }
                    }
                    if (this.keys[' '] && this.player.shootCooldown === 0) {
                        const currentCooldown = this.player.rapidFire > 0 ? Math.floor(this.player.baseShootCooldown / 2) : this.player.baseShootCooldown;
                        this.bullets.push({ x: this.player.x, y: this.player.y - 1, dy: -1, char: '|' });
                        this.player.shootCooldown = currentCooldown; audio.shoot();
                    }
                    this.bullets.forEach(b => b.y += b.dy);
                    this.bullets = this.bullets.filter(b => b.y > 0 && b.y < this.height - 1);
                    this.powerUps.forEach(p => p.y++);
                    this.powerUps = this.powerUps.filter(p => p.y < this.height);
                    this.enemySpawnCounter++;
                    if (!this.bossActive && this.enemySpawnCounter > (80 - this.level * 3)) {
                        const x = Math.floor(Math.random() * (this.width - 2)) + 1; let hp = 1 + Math.floor(this.level / 3);
                        const rand = Math.random() + this.level * 0.04; let type, char;
                        if (rand > 1.05 && this.level >= 5) { type = 'tank'; hp = 3 + this.level; char = 'W'; }
                        else if (rand > 0.75 && this.level >= 3) { type = 'fast'; hp = 1 + Math.floor(this.level/4); char = '>';}
                        else if (rand > 0.4) { type = 'shooter'; char = '▼'; } else { type = 'basic'; char = 'V'; }
                        this.enemies.push({ x, y: 0, hp, type, char, shootCooldown: Math.random() * 60 + 20, vx: type === 'fast' ? (Math.random() > 0.5 ? 0.4 : -0.4) : 0 });
                        this.enemySpawnCounter = 0;
                    }
                    this.enemies.forEach(e => { e.y += 0.04 + this.level * 0.008; e.x += e.vx; if(e.x <= 1 || e.x >= this.width - 2) e.vx *= -1;
                        if (e.type === 'shooter') { e.shootCooldown--; if (e.shootCooldown <= 0) { this.bullets.push({ x: e.x, y: e.y + 1, dy: 1, char: '!', isEnemy: true }); e.shootCooldown = 100 - this.level * 4; } }
                    });
                    for (let i = this.bullets.length - 1; i >= 0; i--) {
                        const b = this.bullets[i]; if (b.isEnemy) continue;
                        for (let j = this.enemies.length - 1; j >= 0; j--) { const e = this.enemies[j];
                            if (Math.floor(b.x) === Math.floor(e.x) && Math.floor(b.y) === Math.floor(e.y)) { audio.hit(); e.hp--; this.bullets.splice(i, 1);
                                if (e.hp <= 0) { this.createExplosion(e.x, e.y, 5); if(Math.random() < 0.35) this.spawnPowerUp(e.x, e.y); this.enemies.splice(j, 1); this.score += 10 * this.level * (e.type === 'tank' ? 3 : 1); audio.explosion(); } break;
                            }
                        }
                    }
                    const takeDamage = (amount) => { this.shakeScreen(6); if (this.player.shield > 0) { this.player.shield -= amount; if (this.player.shield <= 0) audio.shieldDown(); } else { this.player.hp -= amount; } };
                    this.enemies.forEach(e => { if (Math.floor(e.x) === Math.floor(this.player.x) && Math.floor(e.y) === Math.floor(this.player.y)) { takeDamage(15); e.y = this.height; } });
                     this.bullets.forEach(b => { if(b.isEnemy && Math.floor(b.x) === Math.floor(this.player.x) && Math.floor(b.y) === Math.floor(this.player.y)) { takeDamage(b.damage || 10); b.y = this.height; } });
                    for (let i = this.powerUps.length - 1; i >= 0; i--) {
                        const p = this.powerUps[i]; if (Math.floor(p.x) === Math.floor(this.player.x) && Math.floor(p.y) === Math.floor(this.player.y)) { audio.powerUp();
                            if (p.type === 'shield') this.player.shield = Math.min(100, this.player.shield + 50); if (p.type === 'rapid') this.player.rapidFire = 300; if (p.type === 'health') this.player.hp = Math.min(100, this.player.hp + 25); if (p.type === 'bomb') this.player.bombs = Math.min(5, this.player.bombs + 1);
                            if (p.type === 'mothership') { this.player.mothershipTimer = 600; this.player.mothership = { x: this.player.x, y: this.player.y + 1, char: '<=>', shootCooldown: 0 }; }
                            this.powerUps.splice(i, 1); break;
                        }
                    }
                    if (this.player.hp <= 0 || this.enemies.some(e => e.y >= this.height - 1)) { this.gameOver(); }
                    this.explosions.forEach(ex => ex.lifetime--); this.explosions = this.explosions.filter(ex => ex.lifetime > 0);
                    if (!this.bossActive && this.enemies.length === 0 && this.score > this.level * 400 * (this.level / 2)) {
                        if (this.level < 9 && this.level % 3 !== 0) {
                            this.level++; audio.levelUp(); this.showLevelIntro();
                        }
                    }
                },
                updateMothership: function() {
                    const ship = this.player.mothership;
                    if (!ship) return;
                    ship.x += (this.player.x - ship.x) * 0.1;
                    ship.y = this.player.y + 1;
                    ship.shootCooldown--;
                    if (ship.shootCooldown <= 0) {
                        this.bullets.push({ x: ship.x, y: ship.y - 1, dy: -1, char: '^' });
                        ship.shootCooldown = 20; 
                    }
                },
                useBomb: function() {
                    if (this.player.bombs > 0 && !this.isGameOver) { this.player.bombs--; audio.bomb(); this.shakeScreen(20);
                        if (this.bossActive && this.boss) { this.boss.hp -= 50; audio.bossHit(); this.createExplosion(this.boss.x, this.boss.y, 15); } 
                        else { this.enemies.forEach(e => this.createExplosion(e.x, e.y, 10)); this.score += this.enemies.length * 5 * this.level; this.enemies = []; }
                        this.bullets = this.bullets.filter(b => !b.isEnemy);
                    }
                },
                spawnBoss: function() {
                    audio.warning();
                    this.bossActive = true;
                    const bossIndex = Math.min(Math.floor((this.level - 1) / 3), this.bossTypes.length - 1);
                    const bossData = JSON.parse(JSON.stringify(this.bossTypes[bossIndex]));
                    this.boss = {
                        ...bossData,
                        x: this.width / 2, y: 5, hp: bossData.hp + this.level * 10, maxHp: bossData.hp + this.level * 10, vx: 0.3, vy: 0, attackCooldown: 100, attackPatternIndex: 0
                    };
                    if (this.boss.name === 'Cosmic Void') {
                        this.boss.art = this.boss.art_frames[0];
                    }
                },
                updateBoss: function() {
                    if (!this.boss) return; this.boss.x += this.boss.vx;
                    if (this.boss.name === 'Cosmic Void') {
                        this.boss.artUpdateCounter++;
                        if (this.boss.artUpdateCounter > 5) { 
                            this.boss.artUpdateCounter = 0;
                            this.boss.artFrame = (this.boss.artFrame + 1) % this.boss.art_frames.length;
                            this.boss.art = this.boss.art_frames[this.boss.artFrame];
                        }
                    }
                    if (this.boss.x < this.boss.art[0].length/2 + 1 || this.boss.x > this.width - this.boss.art[0].length/2 - 1) { this.boss.vx *= -1; }
                    for (let i = this.bullets.length - 1; i >= 0; i--) {
                        const b = this.bullets[i]; if (b.isEnemy) continue; const bx = Math.floor(b.x), by = Math.floor(b.y); const bossX = Math.floor(this.boss.x), bossY = Math.floor(this.boss.y);
                        const artHeight = this.boss.art.length; const artWidth = this.boss.art[0].length;
                        if (bx >= bossX - artWidth/2 && bx <= bossX + artWidth/2 && by >= bossY - artHeight/2 && by <= bossY + artHeight/2) { this.boss.hp--; audio.bossHit(); this.createExplosion(bx, by, 3); this.bullets.splice(i,1); break; }
                    }
                    this.boss.attackCooldown--;
                    if (this.boss.attackCooldown <= 0) {
                        const pattern = this.boss.attackPatterns[this.boss.attackPatternIndex];
                        switch(pattern.type) {
                            case 'spread': 
                                for(let i = -Math.floor(pattern.count/2); i <= Math.floor(pattern.count/2); i++){ 
                                    this.bullets.push({ x: this.boss.x+i*2, y: this.boss.y + 2, dy: 1, char: '*', isEnemy: true, damage: pattern.damage, styleClass: 'boss-bullet' });
                                } 
                                break;
                            case 'spawn': 
                                for (let i=0; i < pattern.count; i++) {
                                    this.enemies.push({ x: this.boss.x - 5 + i*10, y: this.boss.y, hp: 1 + this.level, type: pattern.enemyType, char: 'v', vx: -0.2 + i*0.4 }); 
                                }
                                break;
                            case 'bombingRun':
                                for (let i = 0; i < pattern.count; i++) {
                                    setTimeout(() => {
                                        if(!this.isGameOver && this.bossActive) {
                                            const bombX = Math.random() * (this.width - 2) + 1;
                                            this.bullets.push({ x: bombX, y: 2, dy: 0.8, char: 'o', isEnemy: true, damage: pattern.damage, styleClass: 'enemy-bullet' });
                                        }
                                    }, i * 100);
                                }
                                break;
                            case 'barrage':
                                 for(let i=0; i<5; i++){ 
                                    setTimeout(() => { if(!this.isGameOver) this.bullets.push({ x: this.boss.x - 2 + Math.random() * 4, y: this.boss.y + 2, dy: 1.2, char: 'i', isEnemy: true, damage: pattern.damage, styleClass: 'boss-bullet' }); }, i * 80); 
                                }
                                break;
                        }
                        this.boss.attackCooldown = pattern.cooldown - this.level * 2;
                        this.boss.attackPatternIndex = (this.boss.attackPatternIndex + 1) % this.boss.attackPatterns.length;
                    }
                    if (this.boss.hp <= 0) {
                         this.createExplosion(this.boss.x, this.boss.y, 50); 
                         this.bossActive = false; this.boss = null; this.score += 1000 * this.level; audio.levelUp(); 
                         if(this.level < 9) {
                            this.level++;
                            this.showLevelIntro();
                         } else {
                            this.gameWin();
                         }
                    }
                },
                drawBoss: function(grid) {
                    if (!this.boss) return; const bossX = Math.floor(this.boss.x), bossY = Math.floor(this.boss.y); const artHeight = this.boss.art.length; const artWidth = this.boss.art[0].length;
                    for (let y = 0; y < artHeight; y++) { for (let x = 0; x < artWidth; x++) { const gridX = bossX - Math.floor(artWidth / 2) + x; const gridY = bossY - Math.floor(artHeight / 2) + y; if (grid[gridY] && grid[gridY][gridX]) { grid[gridY][gridX] = `<span class="boss">${this.boss.art[y][x]}</span>`; } } }
                    const healthBarWidth = 20; const filledWidth = Math.ceil((this.boss.hp / this.boss.maxHp) * healthBarWidth); let healthBar = `${this.boss.name}: [${'█'.repeat(filledWidth)}${'-'.repeat(healthBarWidth - filledWidth)}]`;
                    for(let i=0; i < healthBar.length; i++) { if(grid[1]) grid[1][Math.floor(this.width/2 - healthBar.length/2) + i] = `<span class="boss-health-bar">${healthBar[i]}</span>`; }
                },
                createExplosion: function(x, y, lifetime) { this.explosions.push({ x, y, char: '*', lifetime }); },
                spawnPowerUp: function(x, y) {
                    const rand = Math.random(); let type, char, styleClass;
                    if(rand < 0.15) { type = 'mothership'; char = 'M'; styleClass = 'powerup-mothership'; }
                    else if(rand < 0.4) { type = 'shield'; char = 'S'; styleClass = 'powerup-shield'; }
                    else if (rand < 0.65) { type = 'rapid'; char = 'R'; styleClass = 'powerup-rapid'; }
                    else if (rand < 0.85) { type = 'health'; char = 'H'; styleClass = 'powerup-health'; }
                    else { type = 'bomb'; char = 'B'; styleClass = 'powerup-bomb'; }
                    this.powerUps.push({x, y, type, char, styleClass});
                },
                draw: function() {
                    let grid = Array(this.height).fill(null).map(() => Array(this.width).fill(' '));
                    for(let i = 0; i < this.width; i++) { grid[0][i] = '─'; grid[this.height - 1][i] = '─'; } for(let i = 0; i < this.height; i++) { grid[i][0] = '│'; grid[i][this.width - 1] = '│'; }
                    grid[0][0] = '┌'; grid[0][this.width - 1] = '┐'; grid[this.height-1][0] = '└'; grid[this.height-1][this.width-1] = '┘';
                    let playerChar = this.player.char; if (this.player.shield > 0) playerChar = `(${this.player.char})`; if (!this.isGameOver) { grid[Math.floor(this.player.y)][Math.floor(this.player.x)] = `<span class="player">${playerChar}</span>`; }
                    if (this.player.mothership) { grid[Math.floor(this.player.mothership.y)][Math.floor(this.player.mothership.x)] = `<span class="mothership">${this.player.mothership.char}</span>`; }
                    this.bullets.forEach(b => { if(grid[Math.floor(b.y)]) grid[Math.floor(b.y)][Math.floor(b.x)] = `<span class="${b.styleClass || (b.isEnemy ? 'enemy-bullet' : 'bullet')}">${b.char}</span>`; });
                    this.enemies.forEach(e => { let styleClass = 'enemy'; if (e.type === 'tank') styleClass = 'enemy-tank'; if (e.type === 'fast') styleClass = 'enemy-fast'; if(grid[Math.floor(e.y)]) grid[Math.floor(e.y)][Math.floor(e.x)] = `<span class="${styleClass}">${e.char}</span>`; });
                    this.powerUps.forEach(p => { if(grid[Math.floor(p.y)]) grid[Math.floor(p.y)][Math.floor(p.x)] = `<span class="powerup ${p.styleClass}">${p.char}</span>`; });
                    this.explosions.forEach(ex => { if(grid[Math.floor(ex.y)]) grid[Math.floor(ex.y)][Math.floor(ex.x)] = `<span class="explosion">${ex.char}</span>`; });
                    if(this.bossActive) this.drawBoss(grid);
                    this.display.innerHTML = grid.map(row => row.join('')).join('\n');
                    const shieldStat = this.player.shield > 0 ? `<span>SHIELD: ${Math.max(0, this.player.shield)}</span>` : '';
                    const bombStat = `<span>BOMBS: ${this.player.bombs}</span>`;
                    const mothershipStat = this.player.mothershipTimer > 0 ? `<span>ALLY: ${Math.ceil(this.player.mothershipTimer/20)}s</span>` : '';
                    this.statsDisplay.innerHTML = `<span>SCORE: ${this.score}</span> <span>LEVEL: ${this.level}</span> <span>HP: ${Math.max(0, this.player.hp)}</span> ${shieldStat} ${bombStat} ${mothershipStat}`;
                },
                gameOver: function() {
                    this.isGameOver = true; clearInterval(this.gameLoopInterval);
                    let newHighScore = false;
                    if (this.score > this.highScore) { this.highScore = this.score; localStorage.setItem('voidStrikerHighScore', this.score); newHighScore = true; }
                    let grid = Array(this.height).fill(null).map(() => Array(this.width).fill(' '));
                    const gameOverText = "G A M E   O V E R"; const scoreText = `FINAL SCORE: ${this.score}`; const highScoreText = newHighScore ? "NEW HIGH SCORE!" : `HIGH SCORE: ${this.highScore}`; const restartText = "Press [Enter] to return to terminal";
                    const texts = [gameOverText, scoreText, highScoreText, restartText];
                    texts.forEach((text, index) => { const startX = Math.floor(this.width / 2 - text.length / 2); for(let i = 0; i < text.length; i++) grid[Math.floor(this.height/2 - 3 + index*2)][startX + i] = text[i]; });
                    this.display.innerHTML = grid.map(row => row.join('')).join('\n');
                },
                gameWin: function() {
                    this.isGameOver = true; clearInterval(this.gameLoopInterval);
                    let grid = Array(this.height).fill(null).map(() => Array(this.width).fill(' '));
                    const winText = "V I C T O R Y"; const winSubText = "You have silenced the Void. Humanity is safe... for now."; const scoreText = `FINAL SCORE: ${this.score}`; const restartText = "Press [Enter] to return to terminal";
                    const texts = [winText, winSubText, scoreText, restartText];
                    texts.forEach((text, index) => { const startX = Math.floor(this.width / 2 - text.length / 2); for(let i = 0; i < text.length; i++) grid[Math.floor(this.height/2 - 3 + index*2)][startX + i] = text[i]; });
                    this.display.innerHTML = grid.map(row => row.join('')).join('\n');
                },
                endGame: function() { clearInterval(this.gameLoopInterval); gameContainer.style.display = 'none'; terminalContent.style.display = 'block'; inGame = false; commandInput.focus(); }
            };


            // --- FIREBASE AUTH LISTENER ---
            onAuthStateChanged(auth, user => {
                if (user) { currentUser = user; } else { if (inChat) { ShadowNetwork.exitChat(); } currentUser = null; }
                updateChatUI(inChat && currentUser);
            });
            
            // --- UI STATE UPDATER ---
            function updateChatUI(isChatting) {
                if (inPythonMode) {
                    terminalTitle.textContent = 'Python REPL';
                    terminalPrompt.textContent = pythonCodeBlock ? '... ' : '>>> ';
                } else if (inAIMode) {
                    terminalTitle.textContent = 'CAMEOSKY / AI Assistant';
                    terminalPrompt.innerHTML = '<span>cameosky@ /ask/&nbsp;</span>';
                } else if (inSearchMode) {
                    terminalTitle.textContent = 'CAMEOSKY / Knowledge Nexus';
                    terminalPrompt.textContent = '[nexus@cameosky ~]$';
                } else if(isChatting && currentUser) {
                    const username = currentUser.email.split('@')[0];
                    terminalTitle.textContent = `Greyskin Secure Chat / ${username}`;
                    terminalPrompt.textContent = `[${username}]$`;
                } else {
                    terminalTitle.textContent = 'CAMEOSKY@arch-terminal';
                    terminalPrompt.textContent = '[cameosky@arch ~]$';
                }
            }

            // --- SHADOW NETWORK CHAT SYSTEM (with Firebase) ---
            const ShadowNetwork = {
                enterChat: function() {
                    if (!currentUser) { printOutput("Authentication required. Type 'greyskin' to begin.", false); return; }
                    inChat = true; updateChatUI(true);
                    historyContainer.innerHTML += `<div class="output auth-success"><br>=== SECURE CHANNEL OPENED ===</div>`;
                    const instructions = `Welcome, ${currentUser.email.split('@')[0]}.<br>` + `  - Type your message and press Enter.<br>` + `  - To reply to a message, use <span style="color:#ff8c00">/&lt;number&gt;/ &lt;your_reply&gt;</span><br>`+ `  - To mention a user, use <span style="color:#ff8c00">/@&lt;username&gt;/ &lt;your_message&gt;</span><br>` + `  - Type <span style="color:#ff4500">'exit'</span> to disconnect.`;
                    printOutput(instructions, true);
                    const chatCollection = collection(db, "greyskin_chat");
                    const q = query(chatCollection, orderBy("timestamp", "asc")); 
                    unsubscribeChat = onSnapshot(q, (querySnapshot) => {
                        historyContainer.querySelectorAll('.chat-message').forEach(el => el.remove()); chatMessages = [];
                        querySnapshot.forEach(doc => { const messageData = { id: doc.id, ...doc.data() }; chatMessages.push(messageData); this.displayMessage(messageData, chatMessages.length); });
                        terminalBody.scrollTop = terminalBody.scrollHeight;
                    }, (error) => { console.error("Error listening to chat:", error); printOutput("Error connecting to the shadow network.", false); });
                },
                exitChat: function() { if (unsubscribeChat) { unsubscribeChat(); unsubscribeChat = null; } inChat = false; updateChatUI(false); printOutput("<br>Disconnected from shadow network.", true); },
                sendMessage: async function(text) {
                    if (!inChat || !currentUser || !text.trim()) return;
                    let messageText = text.trim();
                    const replyNumRegex = /^\/(\d+)\/(.*)/; const replyUserRegex = /^\/@(\w+)\/(.*)/;
                    const numMatch = messageText.match(replyNumRegex); const userMatch = messageText.match(replyUserRegex);
                    if (numMatch) { messageText = `<span class="chat-reply-context">(reply to #${numMatch[1]})</span> ${numMatch[2].trim()}`; } else if (userMatch) { messageText = `<span class="chat-reply-context">(to @${userMatch[1]})</span> ${userMatch[2].trim()}`; }
                    try { await addDoc(collection(db, "greyskin_chat"), { user: currentUser.email.split('@')[0], text: messageText, timestamp: serverTimestamp() }); audio.chatMessage();
                    } catch (e) { console.error("Error sending message: ", e); printOutput("Message could not be sent.", false); }
                },
                displayMessage: function(message, number) {
                    if (!message.timestamp) return; if(document.querySelector(`[data-msg-id="${message.id}"]`)) return;
                    const time = message.timestamp.toDate().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const messageElement = document.createElement('div'); messageElement.className = 'chat-message'; messageElement.dataset.msgId = message.id;
                    messageElement.innerHTML = `<span class="chat-message-number">[${number}]</span>` + `<span class="chat-message-time">${time}</span> ` + `<span class="chat-message-user">${message.user}:</span> ` + `<span class="chat-message-text">${message.text}</span>`;
                    historyContainer.appendChild(messageElement);
                }
            };

            function showAnimatedIntro() {
                terminalContent.style.display = 'none';
                searchViewContainer.style.display = 'none';
                gameContainer.style.display = 'none';
                
                const introContainer = document.createElement('div');
                introContainer.id = 'intro-container';
                introContainer.style.cssText = `
                    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                    background: #000; color: #e0e0e0; font-family: 'JetBrains Mono', monospace;
                    display: flex; flex-direction: column; justify-content: center; align-items: center;
                    padding: 20px; text-align: center; z-index: 5000; user-select: none;
                `;

                const pre = document.createElement('pre');
                pre.style.fontSize = '12px';
                pre.style.lineHeight = '1';

                const textOverlay = document.createElement('p');
                textOverlay.style.cssText = `
                    position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
                    max-width: 800px; line-height: 1.7; font-size: 1.1em;
                    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
                `;

                const skipPrompt = document.createElement('p');
                skipPrompt.style.cssText = `
                    position: absolute; bottom: 5%; left: 50%; transform: translateX(-50%);
                    color: #ff4500; animation: blink 1.5s infinite; font-size: 1.1em;
                `;
                skipPrompt.textContent = "Press [Enter] to Skip";

                introContainer.appendChild(pre);
                introContainer.appendChild(textOverlay);
                introContainer.appendChild(skipPrompt);
                terminalBody.appendChild(introContainer);

                let animationTimeout;
                const scenes = [
                    { duration: 4000, text: "Across the cosmos, a signal radiates from a small, blue world..." },
                    { duration: 4000, text: "A signal of life. A signal of... competition." },
                    { duration: 5000, text: "The Spiral God, an ancient cosmic entity, has heard the call." },
                    { duration: 5000, text: "It tolerates no rivals. Its tendrils now reach for Earth." },
                    { duration: 6000, text: "You are the Void-Striker. Humanity's last defense against cosmic silence." }
                ];

                let sceneIndex = 0;
                function runScene() {
                    if (sceneIndex >= scenes.length) {
                        endIntro();
                        return;
                    }
                    textOverlay.textContent = scenes[sceneIndex].text;
                    animationTimeout = setTimeout(runScene, scenes[sceneIndex].duration);
                    sceneIndex++;
                }

                const earth = [
                    '    .oOOOo.    ',
                    '   .OOooOoo.   ',
                    '  .OooOoooOoo. ',
                    ' .ooooooooooo. ',
                    '.ooooooooooooo.',
                    'ooooooooooooooo',
                    'ooooooooooooooo',
                    '.ooooooooooooo.',
                    ' `ooooooooooo` ',
                    '  `OooOoooOoo` ',
                    '   `OOooOoo`   ',
                    '    `oOOOo`    '
                ];
                
                let spiralRadius = 30;
                let spiralAngle = 0;
                function animate() {
                    if (!document.body.contains(introContainer)) return;
                    
                    const width = 80, height = 30;
                    let grid = Array(height).fill(null).map(() => Array(width).fill(' '));

                    // Draw stars
                    for(let i=0; i<50; i++) {
                        grid[Math.floor(Math.random()*height)][Math.floor(Math.random()*width)] = '.';
                    }

                    // Draw Earth
                    earth.forEach((line, y) => {
                        const earthY = Math.floor(height/2 - earth.length/2) + y;
                        const earthX = Math.floor(width/2 - line.length/2);
                        for(let x=0; x < line.length; x++) {
                            if(grid[earthY]) grid[earthY][earthX + x] = line[x];
                        }
                    });

                    // Draw Spiral God
                    if (sceneIndex > 1) {
                        spiralRadius -= 0.1;
                        spiralAngle += 0.1;
                        for(let i=0; i<100; i++) {
                            const t = i * 0.1 + spiralAngle;
                            const r = Math.max(0, spiralRadius) * (i/100);
                            const x = Math.floor(width * 0.8 + r * Math.cos(t));
                            const y = Math.floor(height/2 + r * Math.sin(t));
                            if(grid[y] && grid[y][x]) grid[y][x] = '#';
                        }
                    }
                    
                    pre.textContent = grid.map(row => row.join('')).join('\n');
                    requestAnimationFrame(animate);
                }

                function endIntro() {
                    clearTimeout(animationTimeout);
                    document.removeEventListener('keydown', skipHandler);
                    if (document.body.contains(introContainer)) {
                        terminalBody.removeChild(introContainer);
                    }
                    printOutput("Initializing VOID-STRIKER... Good luck, pilot.", true);
                    Game.init();
                }

                function skipHandler(e) {
                    if (e.key === 'Enter') {
                        endIntro();
                    }
                }
                
                document.addEventListener('keydown', skipHandler);
                animate();
                runScene();
            }

           // --- 3D NEURAL MAP (UPGRADED) ---
            const NeuralMap = {
                scene: null, camera: null, renderer: null, labelRenderer: null, controls: null, raycaster: null, mouse: null,
                graph: { nodes: [], edges: [] },
                threeObjects: { nodes: new Map(), lines: new Map() },
                hoveredElement: null,
                isInitialized: false,

                init() {
                    if (this.isInitialized) return;
                    
                    this.scene = new THREE.Scene();
                    this.scene.fog = new THREE.Fog(0x000000, 25, 60);

                    this.camera = new THREE.PerspectiveCamera(75, neuralMapContainer.clientWidth / neuralMapContainer.clientHeight, 0.1, 1000);
                    this.camera.position.set(0, 0, 25);

                    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    this.renderer.setSize(neuralMapContainer.clientWidth, neuralMapContainer.clientHeight);
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    neuralMapContainer.appendChild(this.renderer.domElement);

                    this.labelRenderer = new CSS2DRenderer();
                    this.labelRenderer.setSize(neuralMapContainer.clientWidth, neuralMapContainer.clientHeight);
                    this.labelRenderer.domElement.style.position = 'absolute';
                    this.labelRenderer.domElement.style.top = '0px';
                    this.labelRenderer.domElement.style.pointerEvents = 'none';
                    neuralMapContainer.appendChild(this.labelRenderer.domElement);

                    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.minDistance = 5;
                    this.controls.maxDistance = 80;
                    this.controls.enablePan = true;

                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                    this.scene.add(ambientLight);
                    const pointLight = new THREE.PointLight(0xff6600, 1, 150);
                    this.camera.add(pointLight);
                    this.scene.add(this.camera);

                    this.raycaster = new THREE.Raycaster();
                    this.mouse = new THREE.Vector2();
                    this.renderer.domElement.addEventListener('click', this.onCanvasClick.bind(this));
                    this.renderer.domElement.addEventListener('mousemove', this.onCanvasMouseMove.bind(this));
                    
                    window.addEventListener('resize', this.onResize.bind(this), false);

                    this.animate();
                    this.isInitialized = true;
                },

                // FIXED: This function now correctly updates line resolutions and handles cases where the container size is 0.
                onResize() {
                    if (!this.isInitialized || !neuralMapContainer.clientWidth) return;

                    const width = neuralMapContainer.clientWidth;
                    const height = neuralMapContainer.clientHeight;

                    // If the container isn't rendered yet, its size will be 0. Prevent errors by returning early.
                    if (width === 0 || height === 0) {
                        return;
                    }

                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();

                    this.renderer.setSize(width, height);
                    this.labelRenderer.setSize(width, height);

                    // This is the crucial fix for resizing. It updates all existing lines.
                    this.threeObjects.lines.forEach(line => {
                        if (line.material) {
                            line.material.resolution.set(width, height);
                        }
                    });
                },

                // FIXED: This function now uses requestAnimationFrame to ensure onResize is called after the DOM is updated.
                show() {
                    neuralMapContainer.style.display = 'block';
                    // Defer the resize call to the next frame to ensure the browser has
                    // calculated the container's dimensions after it becomes visible. This prevents lines from rendering with a size of 0.
                    requestAnimationFrame(() => {
                        this.onResize();
                    });
                },
                hide() { neuralMapContainer.style.display = 'none'; },
                
                clearGraph() {
                    this.graph = { nodes: [], edges: [] };
                    this.threeObjects.nodes.forEach(obj => this.scene.remove(obj.mesh));
                    this.threeObjects.lines.forEach(obj => this.scene.remove(obj));
                    this.threeObjects = { nodes: new Map(), lines: new Map() };
                },
                
                async addTopic(nodeData) {
                    if (this.graph.nodes.some(n => n.id === nodeData.id)) {
                        const existingObj = this.threeObjects.nodes.get(nodeData.id);
                        if(existingObj) this.focusOnNode(existingObj.mesh.position);
                        return;
                    }
                    this.addNode(nodeData);
                    await this.findCrossLinks(nodeData);
                    this.frameGraph();
                },

                focusOnNode(position) {
                    this.controls.target.copy(position);
                    this.camera.position.set(position.x, position.y, position.z + 25);
                },

                addNode(nodeData) {
                    const newNode = {
                        id: nodeData.id,
                        label: nodeData.label,
                        summary: nodeData.summary,
                        position: new THREE.Vector3((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20),
                        velocity: new THREE.Vector3(),
                        mass: nodeData.isRelationship ? 1.0 : 1.5,
                        isRelationship: !!nodeData.isRelationship
                    };
                    this.graph.nodes.push(newNode);
                    this.createNodeObject(newNode);
                },

                async findCrossLinks(newNodeData) {
                    const existingNodes = this.graph.nodes.filter(n => n.id !== newNodeData.id && !n.isRelationship);
                    for (const oldNode of existingNodes) {
                        const commonCategory = await KnowledgeMap.getCommonCategory(oldNode.id, newNodeData.id);
                        if (commonCategory) {
                            const relationId = `relation-${oldNode.id}-${newNodeData.id}`;
                            if (this.graph.nodes.some(n => n.id === relationId)) continue;
                            
                            const relationNodeData = {
                                id: relationId,
                                label: commonCategory,
                                summary: `AI-generated relationship: ${oldNode.label} and ${newNodeData.label} are related because: '${commonCategory}'.`,
                                isRelationship: true
                            };
                            
                            this.addNode(relationNodeData);
                            this.addEdge({ id: `${oldNode.id}__${relationId}`, from: oldNode.id, to: relationId });
                            this.addEdge({ id: `${newNodeData.id}__${relationId}`, from: newNodeData.id, to: relationId });
                        }
                    }
                },
                
                addEdge(edgeData) {
                    const reverseEdgeId = `${edgeData.to}__${edgeData.from}`;
                    if (this.graph.edges.some(e => e.id === edgeData.id || e.id === reverseEdgeId)) return;
                    this.graph.edges.push(edgeData);
                    this.createEdgeObject(edgeData);
                },

                createNodeObject(node) {
                     const isRelationship = node.isRelationship;
                     const geometry = new THREE.SphereGeometry(isRelationship ? 0.4 : 0.6, 20, 20);
                     const material = new THREE.MeshPhongMaterial({ 
                         color: isRelationship ? 0x00ff00 : 0xff4500, // Green for relationships
                         emissive: isRelationship ? 0x00cc00 : 0xff4500, 
                         emissiveIntensity: 0.4,
                         transparent: true,
                         opacity: 0.9
                     });
                     const sphere = new THREE.Mesh(geometry, material);
                     sphere.position.copy(node.position);
                     sphere.userData = { id: node.id, type: 'node', targetScale: 1.0 };
                     
                     const labelDiv = document.createElement('div');
                     labelDiv.className = 'label';
                     labelDiv.textContent = node.label;
                     labelDiv.style.color = isRelationship ? '#aaffaa' : '#ffffff';
                     if (!isRelationship) {
                        labelDiv.addEventListener('click', () => KnowledgeMap.init(node.id));
                     }
                     const label = new CSS2DObject(labelDiv);
                     label.position.set(0, isRelationship ? 0.7 : 0.9, 0);
                     sphere.add(label);

                     this.scene.add(sphere);
                     this.threeObjects.nodes.set(node.id, { mesh: sphere, label: label, material: material });
                },

                createEdgeObject(edge) {
                    const fromNode = this.graph.nodes.find(n => n.id === edge.from);
                    const toNode = this.graph.nodes.find(n => n.id === edge.to);
                    if (!fromNode || !toNode) return;
                    
                    const positions = [fromNode.position.x, fromNode.position.y, fromNode.position.z, toNode.position.x, toNode.position.y, toNode.position.z];
                    const lineGeo = new LineGeometry();
                    lineGeo.setPositions(positions);

                    const lineMat = new LineMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0.4 });
                    lineMat.resolution.set(neuralMapContainer.clientWidth, neuralMapContainer.clientHeight);
                    
                    const line = new Line2(lineGeo, lineMat);
                    line.computeLineDistances();
                    line.scale.set(1, 1, 1);
                    line.userData = { id: edge.id, type: 'edge', from: edge.from, to: edge.to };

                    this.scene.add(line);
                    this.threeObjects.lines.set(edge.id, line);
                },

                applyPhysics() {
                    if (this.graph.nodes.length < 2) return;
                    const repulsionStrength = 0.8;   
                    const attractionStrength = 0.005;
                    const idealDistance = 18.0;     
                    const damping = 0.92;           
                    const maxSpeed = 0.2;            

                    this.graph.nodes.forEach(node => {
                        node.velocity.multiplyScalar(damping);
                        const pullToCenter = node.position.clone().multiplyScalar(-0.00005);
                        node.velocity.add(pullToCenter);
                    });

                    for (let i = 0; i < this.graph.nodes.length; i++) {
                        for (let j = i + 1; j < this.graph.nodes.length; j++) {
                            const nodeA = this.graph.nodes[i];
                            const nodeB = this.graph.nodes[j];
                            const delta = new THREE.Vector3().subVectors(nodeA.position, nodeB.position);
                            const distance = Math.max(1.0, delta.length());
                            
                            const forceMagnitude = repulsionStrength / (distance * distance);
                            const force = delta.normalize().multiplyScalar(forceMagnitude);

                            nodeA.velocity.add(force);
                            nodeB.velocity.sub(force);
                        }
                    }

                    this.graph.edges.forEach(edge => {
                        const nodeA = this.graph.nodes.find(n => n.id === edge.from);
                        const nodeB = this.graph.nodes.find(n => n.id === edge.to);
                        if (nodeA && nodeB) {
                            const delta = new THREE.Vector3().subVectors(nodeA.position, nodeB.position);
                            const distance = Math.max(0.1, delta.length());
                            const displacement = distance - idealDistance;
                            const forceMagnitude = displacement * attractionStrength;
                            const force = delta.normalize().multiplyScalar(forceMagnitude);
                            nodeA.velocity.sub(force);
                            nodeB.velocity.add(force);
                        }
                    });
                    
                    this.graph.nodes.forEach(node => {
                        if (node.velocity.length() > maxSpeed) {
                            node.velocity.normalize().multiplyScalar(maxSpeed);
                        }
                        node.position.add(node.velocity);
                    });
                },

                updateThreeObjects() {
                    this.threeObjects.nodes.forEach((obj, id) => {
                        const node = this.graph.nodes.find(n => n.id === id);
                        if (node) obj.mesh.position.copy(node.position);
                    });
                    this.threeObjects.lines.forEach((line, id) => {
                        const edge = this.graph.edges.find(e => e.id === id);
                        if(edge) {
                            const fromNode = this.graph.nodes.find(n => n.id === edge.from);
                            const toNode = this.graph.nodes.find(n => n.id === edge.to);
                            if(fromNode && toNode) {
                                line.geometry.setPositions([fromNode.position.x, fromNode.position.y, fromNode.position.z, toNode.position.x, toNode.position.y, toNode.position.z]);
                            }
                        }
                    });
                },
                
                onCanvasMouseMove(event) {
                    event.preventDefault();
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    this.raycaster.params.Line.threshold = 0.5; // Sensitivity for line intersection

                    const nodeMeshes = Array.from(this.threeObjects.nodes.values()).map(n => n.mesh);
                    const lineMeshes = Array.from(this.threeObjects.lines.values());

                    const nodeIntersects = this.raycaster.intersectObjects(nodeMeshes);
                    const lineIntersects = this.raycaster.intersectObjects(lineMeshes);

                    let newHoveredElement = null;

                    if (nodeIntersects.length > 0) {
                        newHoveredElement = { type: 'node', id: nodeIntersects[0].object.userData.id };
                    } else if (lineIntersects.length > 0) {
                        newHoveredElement = { type: 'edge', id: lineIntersects[0].object.userData.id };
                    }
                    
                    if (this.hoveredElement?.id !== newHoveredElement?.id || this.hoveredElement?.type !== newHoveredElement?.type) {
                        this.hoveredElement = newHoveredElement;
                        this.updateHighlights();
                    }
                },
                
                onCanvasClick(event) {
                    event.preventDefault();
                    if (this.hoveredElement && this.hoveredElement.type === 'node') {
                        const node = this.graph.nodes.find(n => n.id === this.hoveredElement.id);
                        if (node && !node.isRelationship) {
                           KnowledgeMap.init(this.hoveredElement.id);
                        }
                    }
                },

                updateHighlights() {
                    const highlightedNodes = new Set();
                    const highlightedEdges = new Set();
                    const isAnythingHovered = this.hoveredElement !== null;

                    const GLOW_COLOR = 0xffaa00; 
                    const DULL_OPACITY_NODE = 0.15;
                    const DULL_OPACITY_LINE = 0.05;
                    const NORMAL_OPACITY_NODE = 0.9;
                    const NORMAL_OPACITY_LINE = 0.4;

                    if (isAnythingHovered) {
                        if (this.hoveredElement.type === 'node') {
                            const hoveredNodeId = this.hoveredElement.id;
                            highlightedNodes.add(hoveredNodeId);
                            this.graph.edges.forEach(edge => {
                                if (edge.from === hoveredNodeId || edge.to === hoveredNodeId) {
                                    highlightedEdges.add(edge.id);
                                    highlightedNodes.add(edge.from);
                                    highlightedNodes.add(edge.to);
                                }
                            });
                        } else if (this.hoveredElement.type === 'edge') {
                            const hoveredEdgeId = this.hoveredElement.id;
                            highlightedEdges.add(hoveredEdgeId);
                            const edge = this.graph.edges.find(e => e.id === hoveredEdgeId);
                            if (edge) {
                                highlightedNodes.add(edge.from);
                                highlightedNodes.add(edge.to);
                            }
                        }
                    }

                    this.threeObjects.nodes.forEach((nodeObj, nodeId) => {
                        const isHighlighted = highlightedNodes.has(nodeId);
                        const node = this.graph.nodes.find(n => n.id === nodeId);
                        if (!node) return;
                        const isRelationship = node.isRelationship;

                        nodeObj.material.emissive.setHex(isHighlighted ? GLOW_COLOR : (isRelationship ? 0x00cc00 : 0xff4500));
                        nodeObj.material.emissiveIntensity = isHighlighted ? 1.5 : 0.4;
                        
                        nodeObj.material.opacity = isAnythingHovered && !isHighlighted ? DULL_OPACITY_NODE : NORMAL_OPACITY_NODE;
                        
                        nodeObj.mesh.userData.targetScale = isHighlighted ? 1.4 : 1.0;

                        nodeObj.label.element.style.opacity = isAnythingHovered && !isHighlighted ? DULL_OPACITY_NODE : 1.0;
                        nodeObj.label.element.classList.toggle('highlight', isHighlighted);
                    });

                    this.threeObjects.lines.forEach((lineObj, lineId) => {
                        const isHighlighted = highlightedEdges.has(lineId);
                        
                        lineObj.material.color.set(isHighlighted ? GLOW_COLOR : 0xffffff);

                        lineObj.material.opacity = isAnythingHovered && !isHighlighted ? DULL_OPACITY_LINE : NORMAL_OPACITY_LINE;
                    });
                },
                
                frameGraph() {
                    if (this.graph.nodes.length === 0 || !this.isInitialized) return;
                    const box = new THREE.Box3();
                    this.graph.nodes.forEach(node => box.expandByPoint(node.position));
                    if (box.isEmpty()) return;

                    const size = new THREE.Vector3(); box.getSize(size);
                    const center = new THREE.Vector3(); box.getCenter(center);
                    const maxSize = Math.max(size.x, size.y);
                    const fov = this.camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxSize / 2 / Math.tan(fov / 2));
                    cameraZ *= 1.5; 
                    this.controls.target.copy(center);
                    const newPosition = new THREE.Vector3(center.x, center.y, center.z + Math.max(cameraZ, 25));
                    this.camera.position.copy(newPosition);
                    this.camera.lookAt(center);
                    this.controls.maxDistance = cameraZ * 2;
                    this.controls.update();
                },

                animate() {
                    requestAnimationFrame(this.animate.bind(this));
                    this.applyPhysics();
                    this.updateThreeObjects();
                    this.threeObjects.nodes.forEach(nodeObj => {
                        const targetScale = nodeObj.mesh.userData.targetScale || 1.0;
                        nodeObj.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                    });
                    this.controls.update();
                    this.renderer.render(this.scene, this.camera);
                    this.labelRenderer.render(this.scene, this.camera);
                }
            };
            
            // --- KNOWLEDGE MAP (UPGRADED) ---
            const KnowledgeMap = {
                allFetchedNodes: new Map(),
                container: mapGridContainer,
                infoPanel: infoContent,
                searchHistory: [],
                historyIndex: -1,
                highlightedIndex: -1,
                
                async init(term, fromHistory = false) {
                    this.highlightedIndex = -1; 
                    if (!fromHistory) {
                        if (this.historyIndex < this.searchHistory.length - 1) {
                            this.searchHistory.splice(this.historyIndex + 1);
                        }
                        this.searchHistory.push(term);
                        this.historyIndex++;
                    }
                    
                    searchBackBtn.disabled = this.historyIndex <= 0;
                    searchForwardBtn.disabled = this.historyIndex >= this.searchHistory.length - 1;

                    this.container.innerHTML = `Connecting to Knowledge Matrix for <strong style="color:white">"${term}"</strong>...`;
                    this.infoPanel.innerHTML = `<div class="info-summary">Fetching details for "${term}"...</div>`;
                    imagePanel.innerHTML = `<span class="placeholder-text">Searching for image...</span>`;
                    
                    if (this.allFetchedNodes.has(term)) {
                        const nodeData = this.allFetchedNodes.get(term);
                        this.render(nodeData);
                        await NeuralMap.addTopic(nodeData);
                    } else {
                        await this.fetchData(term);
                    }
                },

                goBack() { if (this.historyIndex > 0) { this.historyIndex--; this.init(this.searchHistory[this.historyIndex], true); } },
                goForward() { if (this.historyIndex < this.searchHistory.length - 1) { this.historyIndex++; this.init(this.searchHistory[this.historyIndex], true); } },

                async fetchData(term) {
                    const WIKI_API = "https://en.wikipedia.org/w/api.php?action=parse&format=json&origin=*&redirects=1&prop=text|images";
                    try {
                        const response = await fetch(WIKI_API + `&page=${encodeURIComponent(term)}`);
                        if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                        const data = await response.json();
                        if (data.error) throw new Error(`'${term}' not found on Wikipedia.`);

                        const pageTitle = data.parse.title;
                        const html = data.parse.text['*'];
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const content = doc.querySelector('.mw-parser-output');
                        if (!content) throw new Error("Could not parse Wikipedia content.");

                        let summary = '';
                        const paragraphs = Array.from(content.querySelectorAll('p:not(.mw-empty-elt)'));
                        for (const p of paragraphs) {
                            const pText = p.textContent.trim().replace(/\[\d+\]/g, '');
                            if (pText.length > 20) { summary += pText + '\n\n'; }
                            if (summary.length > 800) break;
                        }
                        if (!summary) { summary = "No detailed summary could be extracted for this topic."; }

                        const centralNode = { id: pageTitle, label: pageTitle, summary: summary, related: [] };
                        
                        const links = Array.from(content.querySelectorAll('p a[href^="/wiki/"]'));
                        const uniqueLinks = new Set([pageTitle.toLowerCase()]);
                        centralNode.related = links
                            .map(link => ({ title: link.title, href: link.getAttribute('href') }))
                            .filter(link => {
                                if (link.title && !link.href.includes(':') && !uniqueLinks.has(link.title.toLowerCase())) {
                                    uniqueLinks.add(link.title.toLowerCase()); return true;
                                } return false;
                            })
                            .slice(0, 15)
                            .map(link => ({ id: link.title, label: link.title }));
                        
                        this.allFetchedNodes.set(pageTitle, centralNode);
                        
                        this.render(centralNode);
                        await NeuralMap.addTopic(centralNode);

                    } catch (e) {
                        this.container.innerHTML = `<span class="auth-error">Error: ${e.message}</span>`;
                        this.infoPanel.innerHTML = `<div class="info-summary">Please try another search term.</div>`;
                        imagePanel.innerHTML = `<span class="placeholder-text"></span>`;
                        console.error(e);
                    }
                },
                
                render(activeNode) {
                    this.container.innerHTML = '';
                    activeNode.related.forEach(node => {
                        const nodeEl = document.createElement('div');
                        nodeEl.className = 'map-node-retro';
                        nodeEl.dataset.nodeId = node.id;
                        nodeEl.textContent = node.label;
                        nodeEl.addEventListener('click', () => { this.init(node.label); });
                        this.container.appendChild(nodeEl);
                    });
                    this.displayInfo(activeNode);
                    this.fetchImage(activeNode.label);
                    knowledgeSearchInput.focus();
                },
                
                async fetchImage(term) {
                    const API_ENDPOINT = "https://en.wikipedia.org/w/api.php?origin=*&format=json";
                    try {
                        const pageIdRes = await fetch(`${API_ENDPOINT}&action=query&titles=${encodeURIComponent(term)}`);
                        const pageIdData = await pageIdRes.json();
                        const pageId = Object.keys(pageIdData.query.pages)[0];
                        if (pageId === "-1") { throw new Error("Page not found"); }
                        
                        const imgRes = await fetch(`${API_ENDPOINT}&action=query&pageids=${pageId}&prop=pageimages&pithumbsize=400`);
                        const imgData = await imgRes.json();
                        const page = imgData.query.pages[pageId];

                        if (page.thumbnail && page.thumbnail.source) {
                            const img = new Image();
                            img.onload = () => { imagePanel.innerHTML = ''; imagePanel.appendChild(img); };
                            img.onerror = () => { imagePanel.innerHTML = `<span class="placeholder-text">Image not found.</span>`; };
                            img.src = page.thumbnail.source;
                        } else { imagePanel.innerHTML = `<span class="placeholder-text">No image for this topic.</span>`; }
                    } catch (e) { console.error("Image fetch error:", e); imagePanel.innerHTML = `<span class="placeholder-text">Image search failed.</span>`; }
                },

                async getCommonCategory(term1, term2) {
                    const prompt = `In a single, very short sentence (under 7 words), what is the relationship between "${term1}" and "${term2}"? If there is no direct or obvious relationship, just respond with "None".`;
                    const apiKey = ""; 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                    
                    const payload = {
                        contents: [{
                            parts: [{ text: prompt }]
                        }]
                    };

                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            console.error("AI API call failed with status:", response.status);
                            return null;
                        }

                        const result = await response.json();
                        
                        if (result.candidates && result.candidates.length > 0 &&
                            result.candidates[0].content && result.candidates[0].content.parts &&
                            result.candidates[0].content.parts.length > 0) {
                            
                            let text = result.candidates[0].content.parts[0].text.trim();
                            
                            text = text.replace(/["']/g, '');
                            if (text.endsWith('.')) {
                                text = text.slice(0, -1);
                            }

                            if (text.toLowerCase() !== 'none' && text.length > 0) {
                                return text;
                            }
                        }
                    } catch (error) {
                        console.error("Error calling Gemini API:", error);
                        return null;
                    }
                    
                    return null;
                },

                displayInfo(node) {
                    let summaryHtml = node.summary.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    const relatedTitles = node.related.map(n => n.label);
                    relatedTitles.sort((a, b) => b.length - a.length);
                    relatedTitles.forEach(title => {
                        const safeTitle = title.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                        summaryHtml = summaryHtml.replace(new RegExp(`\\b(${safeTitle})\\b`, 'gi'), `<span class="topic-link" data-topic="${title}">$1</span>`);
                    });
                    
                    this.infoPanel.innerHTML = `
                        <div class="info-title">${node.label}</div>
                        <div class="info-summary">${summaryHtml}</div>
                        <div id="ai-analysis-container">
                            <button id="ai-analyze-btn" class="search-nav-btn" style="width:100%; margin-top:10px;">Analyze with AI</button>
                        </div>
                    `;
                    
                    document.getElementById('ai-analyze-btn').addEventListener('click', async () => {
                        const btn = document.getElementById('ai-analyze-btn');
                        const analysisContainer = document.getElementById('ai-analysis-container');
                        btn.disabled = true;
                        btn.textContent = 'Analyzing...';
                        
                        await new Promise(resolve => setTimeout(resolve, 1500)); 
                        
                        const summaryPoints = node.summary
                            .split('\n\n')[0]
                            .split('. ')
                            .filter(s => s.length > 20)
                            .slice(0, 3)
                            .map(s => `<li>${s.trim()}.</li>`).join('');

                        const aiResponseHTML = `
                            <div class="info-title" style="font-size: 1.1em; margin-top: 15px;">AI Analysis</div>
                            <ul class="ai-response" style="padding-left: 20px; margin-top: 5px;">
                                ${summaryPoints || "<li>Could not generate a summary from the provided text.</li>"}
                            </ul>`;

                        analysisContainer.innerHTML = aiResponseHTML;
                    });

                    this.infoPanel.scrollTop = 0;
                },

                updateHighlight(direction) {
                    const gridNodes = this.container.querySelectorAll('.map-node-retro');
                    if (gridNodes.length === 0) return;
                    if (this.highlightedIndex > -1 && gridNodes[this.highlightedIndex]) gridNodes[this.highlightedIndex].classList.remove('highlighted-node');
                    this.highlightedIndex += direction;
                    if (this.highlightedIndex >= gridNodes.length) { this.highlightedIndex = 0; }
                    if (this.highlightedIndex < 0) { this.highlightedIndex = gridNodes.length - 1; }
                    const newNode = gridNodes[this.highlightedIndex];
                    newNode.classList.add('highlighted-node');
                    newNode.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            };
            

            // --- GLOBAL EVENT LISTENERS ---
            document.addEventListener('keydown', (e) => {
                if (inGame) {
                    const key = e.key.toLowerCase(); if (key === 'q') { Game.endGame(); return; } if (key === 'b') { Game.useBomb(); return; }
                    if (Game.isGameOver) { if (e.key === 'Enter') Game.endGame(); return; }
                    Game.keys[e.key] = true; if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
                    return;
                }
                if (inSearchMode) {
                    const activeEl = document.activeElement; const isInputFocused = activeEl === knowledgeSearchInput;
                    if (!isInputFocused) {
                        switch(e.key) {
                            case 'ArrowDown': KnowledgeMap.updateHighlight(1); e.preventDefault(); break;
                            case 'ArrowUp': KnowledgeMap.updateHighlight(-1); e.preventDefault(); break;
                            case 'Enter':
                                if (KnowledgeMap.highlightedIndex > -1) {
                                    const nodeToActivate = document.querySelector('.highlighted-node'); if(nodeToActivate) nodeToActivate.click();
                                } e.preventDefault(); break;
                            case 'Escape': knowledgeSearchInput.focus(); e.preventDefault(); break;
                        }
                    }
                }
            });
            document.addEventListener('keyup', (e) => { if(inGame) Game.keys[e.key] = false; });
            terminalContainer.addEventListener('click', (e) => { if (!inGame) commandInput.focus(); });
            searchBackBtn.addEventListener('click', () => KnowledgeMap.goBack());
            searchForwardBtn.addEventListener('click', () => KnowledgeMap.goForward());
            knowledgeSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const query = knowledgeSearchInput.value.trim();
                    if (query.toLowerCase() === 'quit') { handleSearchCommand('quit'); } else if (query) { KnowledgeMap.init(query); }
                    knowledgeSearchInput.value = '';
                }
            });
            infoContent.addEventListener('click', (e) => {
                if (e.target.classList.contains('topic-link')) {
                    const topic = e.target.dataset.topic; if (topic) { KnowledgeMap.init(topic); }
                }
            });

            // --- INTERACTIVE TERMINAL LOGIC ---
            commandInput.addEventListener('keydown', function(event) {
                if (inGame) return;
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const commandText = commandInput.value.trim();
                    if (!commandText && !authState.inProgress && !pythonCodeBlock) return;
                    if(inSearchMode) {
                        if(commandText.toLowerCase() === 'quit') { handleSearchCommand('quit'); } else { KnowledgeMap.init(commandText); }
                        commandInput.value = ''; return;
                    }
                    let promptContent = terminalPrompt.textContent;
                    if (!(authState.inProgress && authState.step === 2)) {
                         let historyLine = document.createElement('div'); historyLine.className = 'terminal-line'; historyLine.innerHTML = `<span class="prompt">${promptContent}</span><span class="command">${commandText}</span>`;
                         historyContainer.appendChild(historyLine);
                    } else {
                         let historyLine = document.createElement('div'); historyLine.innerHTML = `<div class="terminal-line"><span class="prompt">${promptContent}</span><span class="command">**********</span></div>`;
                         historyContainer.appendChild(historyLine);
                    }
                    if (inAIMode) { handleAIChatInput(commandText); } 
                    else if (inPythonMode) { handlePythonInput(commandText); } 
                    else if (authState.inProgress) { handleAuthFlow(commandText); } 
                    else if (inChat) { handleChatCommand(commandText); } 
                    else { processCommand(commandText); }
                    commandInput.value = ''; terminalBody.scrollTop = terminalBody.scrollHeight;
                } else if (event.key === 'Backspace' && commandInput.value.length > 0) { audio.delete(); }
            });

            function processCommand(command) {
                let outputElement = document.createElement('div'); outputElement.className = 'output';
                const [cmd, ...args] = command.split(' '); const query = args.join(' ');
                switch(cmd.toLowerCase()) {
                    case 'play': showAnimatedIntro(); break;
                    case 'exit': outputElement.textContent = `This command is used to exit specific modes like chat or the game.`; audio.error(); break;
                    case 'python':
                        if (pyodideReady) { inPythonMode = true; updateChatUI(); outputElement.innerHTML = `Entered Python REPL. Type your Python code. Multi-line statements are supported. Type 'exit()' to leave.`; } 
                        else { outputElement.innerHTML = `Python runtime is still loading or failed to load. Please wait.`; audio.error(); } break;
                    case 'ask':
                        inAIMode = true; updateChatUI();
                        outputElement.innerHTML = `Entered AI chat mode. I'm listening.<br>Type 'quit' to exit this mode.`;
                        if (query) { getAiResponse(query); } break;
                    case 'search':
                        if (query) {
                            if (!NeuralMap.isInitialized) NeuralMap.init();
                            inSearchMode = true; updateChatUI(); terminalContent.style.display = 'none'; 
                            searchViewContainer.style.display = 'flex'; NeuralMap.show(); KnowledgeMap.init(query);
                        } else { outputElement.textContent = 'Usage: search <query>'; audio.error(); } break;
                    case 'greyskin':
                        if (currentUser) { printOutput("Already authenticated. Entering chat...", true); ShadowNetwork.enterChat(); } 
                        else { outputElement.innerHTML = `<span class="secret-prompt">Secure channel initiated...</span>`; outputElement.classList.add('auth-prompt'); setTimeout(() => { authState.inProgress = true; authState.step = 0; printOutput("Select authentication method: [login] or [register]", true); }, 500); } break;
                     case 'logout':
                        if (currentUser) { signOut(auth).then(() => { printOutput("You have been successfully logged out.", true); }).catch((error) => { printOutput(`Logout failed: ${error.message}`, false); }); } 
                        else { printOutput("No user is currently logged in.", false); } break;
                    case 'whoami': outputElement.textContent = currentUser ? currentUser.email.split('@')[0] : 'guest'; break;
                    case 'date': outputElement.textContent = new Date().toString(); break;
                    case 'neofetch':
                        const neofetchUser = currentUser ? currentUser.email.split('@')[0] : 'guest';
                        outputElement.innerHTML = `<pre style="color:#ff4500">${neofetchUser}@cameosky
<span style="color:#c7c7c7">------------------</span>
<span style="color:#c7c7c7">OS: </span>Arch Terminal
<span style="color:#c7c7c7">Host: </span>CAMEOSKY Web
<span style="color:#c7c7c7">Kernel: </span>JavaScript (ES2023)
<span style="color:#c7c7c7">Shell: </span>DOM v7.0
<span style="color:#c7c7c7">DE: </span>Retro
<span style="color:#c7c7c7">Theme: </span>OrangeSpice
<span style="color:#c7c7c7">Terminal: </span>CAMEOSKY
<span style="color:#c7c7c7">CPU: </span>Your Browser
<span style="color:#c7c7c7">GPU: </span>Your GPU
<span style="color:#c7c7c7">Memory: </span>Finite</pre>`;
                        break;
                     case 'help':
                        outputElement.innerHTML = `Available commands:\n` + `  play              - Start the VOID-STRIKER game\n` + `  python            - Enter the interactive Python REPL\n` + `  search <query>    - Generate a visual knowledge map\n` + `  ask <question>    - Enter interactive AI chat mode\n` + `  greyskin          - Authenticate and enter the secure chat\n` + `  logout            - Log out of your account\n` + `  whoami            - Display current user\n` + `  date              - Show current date and time\n` + `  clear             - Clears the terminal history\n` + `  exit              - Used inside chat or python modes`; break;
                    case 'clear': historyContainer.innerHTML = ''; return;
                    default: outputElement.textContent = `Command not found: ${command}. Type 'help' for a list of available commands.`; audio.error();
                }
                historyContainer.appendChild(outputElement);
            }
            
            function handleSearchCommand(command) {
                if (command.toLowerCase() === 'quit') {
                    inSearchMode = false; updateChatUI(); searchViewContainer.style.display = 'none'; 
                    terminalContent.style.display = 'block'; NeuralMap.hide(); commandInput.focus();
                    printOutput("Exited Knowledge Nexus.", true);
                    // Clear the graph for the next session
                    NeuralMap.clearGraph();
                    KnowledgeMap.allFetchedNodes.clear();
                }
            }
            function handleAIChatInput(command) { if (command.toLowerCase() === 'quit') { inAIMode = false; updateChatUI(); printOutput("Exited AI chat mode.", true); return; } if(command) getAiResponse(command); }
            function handlePythonInput(command) {
                if (command === 'exit()' || command === 'quit()') { inPythonMode = false; pythonCodeBlock = ''; updateChatUI(); printOutput("Exited Python REPL.", null); return; }
                pythonCodeBlock += command + '\n';
                if (command.trim().endsWith(':') || command.trim().endsWith('(') || command.trim().endsWith('[') || command.trim().endsWith('{') || (pythonCodeBlock && command.trim() !== '')) { updateChatUI(); } 
                else { runPythonCode(pythonCodeBlock); pythonCodeBlock = ''; updateChatUI(); }
            }
            function handleAuthFlow(input) {
                switch(authState.step) {
                    case 0: if (input === 'login' || input === 'register') { authState.mode = input; authState.step = 1; printOutput("Enter email:", true); } else { printOutput("Invalid option. Type 'login' or 'register'", false); } break;
                    case 1: authState.email = input; authState.step = 2; printOutput("Enter password:", true); commandInput.type = 'password'; break;
                    case 2: authState.password = input; commandInput.type = 'text'; const action = authState.mode === 'login' ? signInWithEmailAndPassword : createUserWithEmailAndPassword;
                        action(auth, authState.email, authState.password).then((userCredential) => { printOutput(`Authentication successful.`, true); audio.accessGranted(); ShadowNetwork.enterChat(); resetAuthState(); })
                            .catch((error) => { printOutput(`Error: ${error.message.replace('Firebase: ', '')}`, false); audio.accessDenied(); resetAuthState(); }); break;
                }
            }
            function resetAuthState() { authState.inProgress = false; authState.mode = null; authState.step = 0; authState.email = ''; authState.password = ''; }
            function handleChatCommand(command) { if (command.toLowerCase() === 'exit') { ShadowNetwork.exitChat(); return; } ShadowNetwork.sendMessage(command); }
            function printOutput(text, isSuccess, customClass = 'output') {
                const outputElement = document.createElement('div'); outputElement.className = customClass;
                outputElement.innerHTML = text;
                if (isSuccess === true) { outputElement.classList.add('auth-success'); } else if (isSuccess === false) { outputElement.classList.add('auth-error'); }
                historyContainer.appendChild(outputElement); terminalBody.scrollTop = terminalBody.scrollHeight;
            }

            // --- INITIALIZATION ---
            generateSpiralPaths();
            runAsciiAnimation(document.getElementById('ascii-animation-container'), false);
            initializePyodide();
            commandInput.focus();
        });
    </script>
</body>
</html>

